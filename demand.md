文件系统 (Input) -> 对象树 (Node Tree) -> Markdown 文本 -> README.md (Output)




物理存储结构（文件系统） vs 逻辑展示结构（阅读目录）。

深度需求拆解：

第一层：基础映射能力（必须解决的问题）

这是最底层的逻辑，解决“能生成”的问题。

1. 节点识别逻辑 (Identity)

我们需要定义哪些东西应该进入目录。

文件（Leaf Node）：所有的 .md 文件都是潜在的目录项。

文件夹（Branch Node）：所有的文件夹都是潜在的章节标题。

排除机制（Filter）：必须有一个通用的排除规则。

通用排除：.git, node_modules, .github。

资源排除：images, assets, res（这些文件夹存图片的，不该出现在目录里）。

系统排除：_sidebar.md, LICENSE。

2. 命名提取策略 (Naming)

机器看到的 01_introduction.md，人想看的是 “第一章：项目介绍”。

策略 A（文件名兜底）：如果什么都不做，直接用文件名（去除扩展名）。

策略 B（内容优先，通用解法）：这是最推荐的。 脚本必须打开文件，读取第一行非空内容或第一个 # H1 标题。

优势：你甚至不需要重命名文件，文件名可以是 a.md，只要里面写了 # 深度学习导论，目录就显示“深度学习导论”。

策略 C（文件夹命名）：文件夹没有内容，怎么办？

方案一：直接用文件夹名。

方案二：检测文件夹内是否有 README.md 或 index.md，读取该文件的标题作为文件夹的显示名称。

3. 路径标准化 (Linking)

相对路径计算：目录通常生成在根目录的 README.md，所以链接必须是 ./docs/chapter1/file.md。

URL 编码：中文文件名在 URL 中必须转码（如 测试 -> %E6%B5%8B%E8%AF%95），否则在某些浏览器或 GitHub 上点击会 404。

第二层：排序与结构化（决定好不好用的问题）

这是用户体验的核心。文件系统默认是按 ASCII 码排序的，这通常不符合阅读顺序（例如 10.md 会排在 2.md 前面）。

1. 智能排序逻辑 (Sorting)

我们要让机器懂“顺序”，通常有三种“通用协议”：

协议 A：前缀排序（最常用）

用户在文件名加数字：01_基础.md, 02_进阶.md。

生成逻辑：解析时提取前缀数字进行排序，但在生成目录文字时自动剥离前缀。

效果：文件叫 01_Intro.md -> 目录显示 Intro。

协议 B：混合排序

文件夹和文件混排时，通常文件夹（章节）在特定位置，或者置顶。需要定义“文件夹优先”还是“文件优先”。

2. 层级深度控制 (Depth)

不是所有项目都需要无限层级。

通用配置：需要一个 max_depth 参数。比如只展示到 2 级目录，3 级及以下的内容虽然存在，但不显示在 README 首页，以免喧宾夺主。

第三层：扩展性与元数据（高级自动化）

如果要把这个方案做成“通用标准”，还要考虑以下扩展：

1. 锚点注入机制 (Injection)

不要暴力覆盖整个 README.md。

需求：用户可能在 README 里写了项目介绍、徽章、协议。

方案：定义一对“注释标签”作为插槽。

Markdown


(脚本只更新这里面的内容，保留头部和尾部)

2. 多种展示形态 (Presentation)

通过一套分析逻辑，可以输出不同的结果：

标准形态：Markdown 列表（GitHub 默认）。

Markdown



- [章节一](...)  - [小节一](...)

表格形态：如果一级目录很多，列表太长，可以扩展为自动生成表格（如你提供的截图中的贡献者名单风格，甚至可以用表格来排版目录）。

侧边栏配置：这套逻辑完全可以用来生成 _sidebar.md (VuePress/Docsify)，实现静态博客的自动化。

总结：理想的通用自动化流程

基于以上分析，一个不用人操心的自动化目录构建流应该是这样的：

用户操作：只管在 docs/ 里写文章，文件名随便起（或者带数字前缀控制顺序），标题写在文章内容里。

触发器：保存文件 (Watch 模式) 或 Git Push。

解析器：

扫描 docs/ 树。

过滤掉 images/ 等杂项。

读取每个文件的 H1 标题。

根据文件名前缀 (01_, 02_) 进行排序。

剥离文件名前缀，使用 H1 标题作为 Display Name。

生成器：将树结构渲染成 Markdown 文本。

注入器：找到 README.md 里的 `` 标记并更新。

<!--toc-->